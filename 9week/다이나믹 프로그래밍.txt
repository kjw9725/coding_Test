다이나믹 프로그래밍(동적계획법)
1. 메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상시키는 방법
2. 이미계산된 결과는 별도의 메모리 영역에 저장하여 다시계산하지 않도록 한다
3. 탑다운방식과 보텀업방식 두가지로 구성된다

다이나믹 프로그래밍의 조건
1. 최적 부분 구조 - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할수 있다
2. 중복되는 부분 문제 - 동일한 작은 문제를 반복적으로 해결해야 한다

ex) 피보나치 수열
1,1,2,3,5,8,13,21,34,55,89...
a[n] = a[n-1] + a[n-2]

단순 재귀 소스코드(다이나믹 프로그래밍x)
def fibo(x):
	if x == 1 or x ==2:
		return 1
	return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
x의 크기가 커지면 커질수록 중복되는 부분문제가 생기고 시간복잡도가 올라감
(다이나믹프로그래밍에서는 중복되는 부분을 메모리에 기록해서 중복으로 연산되지않게함)

메모이제이션: 한 번 계산한 결과를 메모리 공간에 메모하는 기법

탑다운 vs 보텀업
탑다운(하향식): 큰문제부터 아래로 확인해나가면서 작은문제를 재귀적으로 해결(재귀함수 활용)
보텀업(상향식): 작은문제부터 해결해가면서 큰문제를 활용(반복문 활용)

피보나치: 탑다운 나이나믹 프로그래밍
# 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x):
	# 종료 조건(1혹은 2일때 1을 반환)
	if x == 1 or x == 2:
		return 1
	# 이미 계산한 적 있는 문제라면 그대로 반환
	if d[x] != 0:
		return d[x]
	# 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
	d[x] = fibo(x - 1) + fibo(x - 2)
	return d[x]

print(fibo(99))

피보나치: 보텀업 다이나믹 프로그래밍
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3, n+1):
	d[i] = d[i - 1] + d[i - 2]

print(d[n])

다이나믹 프로그래밍 vs 분할 정복
공통점 - 둘다 최적 부분 구조(큰 문제를 작은 문제로 나눌수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있을때)를 가질때 사용 가능
차이점 - 부분문제의 중복
 다이나믹 프로그래밍은 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복
 분할 정복은 동일한 부분 문제가 반복저긍로 계산되지 않는다

다이나믹 프로그래밍 문제에 접근하는 방법
1. 주어진 문제가 다이나믹 프로그래밍 유형인지 파악한다
2. 그리디, 구현, 완전 탐색등의 아이디어로 문제를 해결할 수 있는지 검토한다(다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려)
3. 재귀함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤 탑다운방식을 사용할수 있으면 코드를 개선하는방법을 사용할수 있다
4. 일반적인 코딩테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많다(코딩이 아니라 점화식을 생각해내는데 시간을 많이 소비할수 있기 때문)
 








 

